{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#test","title":"Test","text":""},{"location":"#test_1","title":"Test","text":""},{"location":"#test_2","title":"Test","text":""},{"location":"cpp/Pointers_and_Initialization/","title":"Pointers and Initialization","text":"<p>Be careful!</p> <p>Be careful whenever creating a new raw pointer</p> <p>e.g. like this <pre><code>int* p_IntTest = new int(5);\n</code></pre> This here will allocate to the memory.</p> <p>See:</p> <ul> <li>https://godbolt.org/z/WqnT8957Y</li> <li> <p>https://godbolt.org/z/Wzn1WcPhs </p> </li> <li> <p>https://godbolt.org/z/7xPTYxWMx - To showcase raw pointers within structs and de-constructors</p> </li> <li>https://godbolt.org/z/vjvn3aj49</li> </ul> <p></p> <p>Such pointers need to be manually deleted, or else it will result in a Memory Leak.</p> <p>To delete you'd do this here below. Just make sure it hasn't been deleted already, otherwise it's gonna give a \"double free error\". <pre><code>delete p_IntTest;\n\n// Optionally, you can set it to nullptr\n// https://stackoverflow.com/a/49509254/11161500\np_IntTest = nullptr;\n</code></pre></p> <p>However, in C++ there are very additional special pointers, e.g. std::unique_ptr</p> <p>Note on godbolt <code>-fsanitize=address</code> can hint on Memory Leaks. LeakSanitizer doesn't exist on Windows though. But there are workarounds for it as well.</p> <p>Additionally:</p> <p><code>-Wall -Wextra -Werror -Wpedantic</code> or on Windows <code>/W4</code>, I think.</p> <p> </p>"},{"location":"cpp/Smart_Pointers/","title":"Smart Pointers","text":"<p><sub>See also https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp</sub> <sub>Note: See also https://en.cppreference.com/book/intro/smart_pointers</sub> </p> <p>In modern C++, Smart Pointers are Pointers that have their own sort of memory management \"technology\", at cost of heap allocation. Depends, what kind of Smart Pointer, I guess.</p> <p>This means that these smart pointers seem to know their scope and if they're unused, they should delete the managed object and itself. Note that the smart pointer is also an object and deletes itself as well. A <code>unique_ptr</code> can be re-used but will delete the managed object if the methods are used properly. e.g. swapping</p> <p>It's basically like initializing a raw pointer, except that it can call <code>delete</code> on its own.</p>"},{"location":"cpp/Smart_Pointers/#stdunique_ptr","title":"<code>std::unique_ptr</code>","text":"<p><code>std::unique_ptr&lt;T, Deleter (optional)&gt;</code></p> <p>Create a <code>unique_ptr</code> for a defined type <code>T</code>, with an optional custom Deleter, e.g. if you wanted to log the deletions for debugging purposes.</p> <p>It also provides methods to swap pointers out and more. See the C++ docs for more info.</p> <p>A <code>unique_ptr</code> can be created out of an already existing pointer or through <code>std::make_unique</code>.</p> <p>See here what happens when you provide an already existing pointer: https://godbolt.org/z/WeG39GfzK <code>.reset(nullptr)</code> can be used, if one wanted to </p> <p> </p> <p>See this https://godbolt.org/z/7njs4Kdx6 which sort of shows a full comprehensive overview of <code>std::unique_ptr</code> itself alone.</p> <p>See also https://godbolt.org/z/65Mvx876v and https://godbolt.org/z/7PsrYdWx7 for a sort of comparison for with and without <code>std::unique_ptr</code>.</p> <p>Additionally:</p> <ul> <li>https://godbolt.org/z/TG7j4PnGv - Showcasing that de-constructors get called when destroyed as well, like expected</li> <li>https://godbolt.org/z/hcn8xdTjo and https://godbolt.org/z/WP7ae55qq</li> <li>https://godbolt.org/z/4Meo9zWej</li> <li>https://godbolt.org/z/zb5nneEzb</li> <li>https://godbolt.org/z/q7h8M7rzY</li> <li>https://godbolt.org/z/q68dfxh1d</li> </ul> <p></p> <p>Also, see this for within structs:</p> <ul> <li>https://godbolt.org/z/vsKMh9oc5 and https://godbolt.org/z/jKaGv45Ks</li> </ul>"},{"location":"cpp/Smart_Pointers/#stdmake_unique","title":"<code>std::make_unique</code>","text":"<p><code>std::make_unique</code> can be used to directly intialize a <code>std::unique_ptr</code>'s value with <code>=</code>.</p> <p>Note that, if you have raw pointers in a struct, that they are still due to manual memory management, unless replaced with a Smart Pointer.</p> <p>Note that <code>std::make_unique</code> returns a <code>std::unique_ptr</code>.</p> <pre><code>std::unique_ptr&lt;int&gt; uniquePointer = std::make_unique&lt;int&gt;(123);\n</code></pre> <p><sub>It's better like that, instead of passing it into the constructor of <code>std::unique_ptr variable()</code> itself. If you see it in any example code, don't mind it but avoid actually doing that, I guess.</sub></p> <p></p>"},{"location":"cpp/Smart_Pointers/#stdshared_ptr","title":"<code>std::shared_ptr</code>","text":"<p>Unlike <code>std::unique_ptr</code>, a <code>std::shared_ptr</code> will only delete the managed object, when there are no <code>shared_ptr</code> left which own that said object. This is why it's called \"shared\", while \"unique\" is limited to own the same object once across all <code>unique_ptr</code>, otherwise there may be unexpected issues.</p> <p><sub>See https://godbolt.org/z/vsTE9cssG and https://godbolt.org/z/fjPMnYWcT for what would happen if more than one <code>unique_ptr</code> would initialize from the same pointer.</sub></p> <p>See https://godbolt.org/z/xd9Tz184n and https://godbolt.org/z/YMYGK6Wh9.</p> <p><code>std::shared_ptr</code> that own the same object, will obviously also point at the same address. Hence why a \"shared pointer\".</p>"},{"location":"cpp/Smart_Pointers/#stdmake_shared","title":"<code>std::make_shared</code>","text":"<p><code>std::make_shared</code> is used to create a shared object that can be used by multiple <code>std::shared_ptr</code>.</p> <p>You should use <code>std::make_shared</code> for <code>std::shared_ptr</code>. If <code>std::shared_ptr</code> is not in the same control block, it may believe, that it is the sole owner and unexpectedly delete the object.</p> <p>Note that <code>std::make_shared</code> returns a <code>std::shared_ptr</code>.</p> <pre><code>std::shared_ptr&lt;int&gt; sharedPointer = std::make_shared&lt;int&gt;(123);\n</code></pre> <p></p>"},{"location":"cpp/Smart_Pointers/#stdweak_ptr","title":"<code>std::weak_ptr</code>","text":"<p>A <code>std::weak_ptr</code> is used to point to other <code>std::shared_ptr</code> without actually claiming ownership of one.</p> <p>See https://godbolt.org/z/eGabaY1WG.</p> <p></p> <p>It's also used to break cycles, e.g. useful when having a \"Node\" that points to previous nodes.</p> <p>For instance, you may want the parent Node to be a \"weak reference\", and the child node a full <code>std::shared_ptr</code>, so that the Node owns the child object.</p> <p>For instance, in a Folder structure, Folder A is in Folder B, and Folder B owns things inside of it. However, Folder B is the parent of Folder A. Hence why Folder B should not own Folder A. Therefore a <code>std::weak_ptr</code> should be used.</p> <p></p>"},{"location":"cpp/Smart_Pointers/#stdmove-with-smart-pointers","title":"<code>std::move</code> with Smart Pointers","text":"<p><code>std::move</code> is also useful for non-copyable objects.</p> <p>This here would make <code>valuePtr</code> not own an object when it gets moved to the other <code>std::unique_ptr</code>.</p> <pre><code>std::unique_ptr&lt;int&gt; valuePtr(new int(15));\nstd::unique_ptr&lt;int&gt; valuePtrNow(std::move(valuePtr));\n</code></pre> <p>See also:</p> <ul> <li>https://godbolt.org/z/f99Pq5vzP</li> <li>https://godbolt.org/z/vWeo7Toje</li> </ul>"}]}